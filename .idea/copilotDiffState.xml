<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/securelink/model/ApiResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/securelink/model/ApiResponse.kt" />
              <option name="originalContent" value="package com.example.securelink.model&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;// Respuesta de LOGIN&#10;data class LoginResponse(&#10;    @SerializedName(&quot;token&quot;)&#10;    val token: String&#10;)&#10;&#10;// Respuesta de REGISTRO&#10;data class RegisterResponse(&#10;    val token: String,&#10;    val userId: Int,&#10;    val username: String&#10;)&#10;&#10;" />
              <option name="updatedContent" value="package com.example.securelink.model&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;// Respuesta de LOGIN&#10;data class LoginResponse(&#10;    @SerializedName(&quot;token&quot;)&#10;    val token: String&#10;)&#10;&#10;// Respuesta de REGISTRO&#10;data class RegisterResponse(&#10;    val token: String,&#10;    val userId: Int,&#10;    val username: String?&#10;)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/securelink/viewmodel/RegistroViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/securelink/viewmodel/RegistroViewModel.kt" />
              <option name="originalContent" value="package com.example.securelink.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.securelink.model.Data.SessionManager&#10;import com.example.securelink.model.RegistroUiState&#10;import com.example.securelink.repository.AuthRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlin.text.toInt&#10;&#10;class RegistroViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val _estado = MutableStateFlow(RegistroUiState())&#10;    val estado: StateFlow&lt;RegistroUiState&gt; = _estado.asStateFlow()&#10;&#10;    private val authRepository = AuthRepository()&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    fun onNombreChange(valor: String) {&#10;        _estado.update { it.copy(nombre = valor, error = null) }&#10;    }&#10;&#10;    fun onCorreoChange(valor: String) {&#10;        _estado.update { it.copy(correo = valor, error = null) }&#10;    }&#10;&#10;    fun onContrasenaChange(valor: String) {&#10;        _estado.update { it.copy(contrasena = valor, error = null) }&#10;    }&#10;&#10;    fun onConfirmarContrasenaChange(valor: String) {&#10;        _estado.update { it.copy(confirmarContrasena = valor, error = null) }&#10;    }&#10;&#10;    private fun validarCampos(): String? {&#10;        val estadoActual = _estado.value&#10;&#10;        return when {&#10;            estadoActual.nombre.isBlank() -&gt;&#10;                &quot;El nombre no puede estar vacío&quot;&#10;&#10;            estadoActual.correo.isBlank() -&gt;&#10;                &quot;El correo no puede estar vacío&quot;&#10;&#10;            !estadoActual.correo.contains(&quot;@&quot;) -&gt;&#10;                &quot;Ingresa un correo válido&quot;&#10;&#10;            estadoActual.contrasena.isBlank() -&gt;&#10;                &quot;La contraseña no puede estar vacía&quot;&#10;&#10;            estadoActual.contrasena.length &lt; 6 -&gt;&#10;                &quot;La contraseña debe tener al menos 6 caracteres&quot;&#10;&#10;            estadoActual.contrasena != estadoActual.confirmarContrasena -&gt;&#10;                &quot;Las contraseñas no coinciden&quot;&#10;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    fun registrarUsuario(onRegistroExitoso: () -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            val errorValidacion = validarCampos()&#10;            if (errorValidacion != null) {&#10;                _estado.update { it.copy(error = errorValidacion) }&#10;                return@launch&#10;            }&#10;&#10;            _estado.update { it.copy(isLoading = true, error = null) }&#10;&#10;            val estadoActual = _estado.value&#10;&#10;            val result = authRepository.register(&#10;                nombre = estadoActual.nombre,&#10;                email = estadoActual.correo,&#10;                password = estadoActual.contrasena&#10;            )&#10;&#10;            result.onSuccess { response -&gt;&#10;                Log.d(&quot;RegistroViewModel&quot;, &quot;Registro exitoso - Token: ${response.token}, UserId: ${response.userId}, Username: ${response.username}&quot;)&#10;&#10;                // Guardar datos de sesión usando los datos de la respuesta&#10;                sessionManager.guardarSesionCompleta(&#10;                    idUsuario = response.userId,&#10;                    nombre = response.username,&#10;                    correo = estadoActual.correo, // Usamos el correo que el usuario ingresó&#10;                    token = response.token&#10;                )&#10;&#10;                _estado.update {&#10;                    it.copy(&#10;                        registroExitoso = true,&#10;                        error = null,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;&#10;                onRegistroExitoso()&#10;            }.onFailure { error -&gt;&#10;                val mensajeError = when {&#10;                    error.message?.contains(&quot;409&quot;) == true -&gt;&#10;                        &quot;El correo ya está registrado&quot;&#10;&#10;                    error.message?.contains(&quot;timeout&quot;) == true -&gt;&#10;                        &quot;Error de conexión&quot;&#10;&#10;                    else -&gt;&#10;                        error.message ?: &quot;Error al registrar usuario&quot;&#10;                }&#10;&#10;                _estado.update {&#10;                    it.copy(&#10;                        registroExitoso = false,&#10;                        error = mensajeError,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    fun clearError() {&#10;        _estado.update { it.copy(error = null) }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.securelink.viewmodel&#10;&#10;import android.app.Application&#10;import android.util.Base64&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import org.json.JSONObject&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.securelink.model.Data.SessionManager&#10;import com.example.securelink.model.RegistroUiState&#10;import com.example.securelink.repository.AuthRepository&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import kotlin.text.toInt&#10;&#10;class RegistroViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val _estado = MutableStateFlow(RegistroUiState())&#10;    val estado: StateFlow&lt;RegistroUiState&gt; = _estado.asStateFlow()&#10;&#10;    private val authRepository = AuthRepository()&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    fun onNombreChange(valor: String) {&#10;        _estado.update { it.copy(nombre = valor, error = null) }&#10;    }&#10;&#10;    fun onCorreoChange(valor: String) {&#10;        _estado.update { it.copy(correo = valor, error = null) }&#10;    }&#10;&#10;    fun onContrasenaChange(valor: String) {&#10;        _estado.update { it.copy(contrasena = valor, error = null) }&#10;    }&#10;&#10;    fun onConfirmarContrasenaChange(valor: String) {&#10;        _estado.update { it.copy(confirmarContrasena = valor, error = null) }&#10;    }&#10;&#10;    private fun validarCampos(): String? {&#10;        val estadoActual = _estado.value&#10;&#10;        return when {&#10;            estadoActual.nombre.isBlank() -&gt;&#10;                &quot;El nombre no puede estar vacío&quot;&#10;&#10;            estadoActual.correo.isBlank() -&gt;&#10;                &quot;El correo no puede estar vacío&quot;&#10;&#10;            !estadoActual.correo.contains(&quot;@&quot;) -&gt;&#10;                &quot;Ingresa un correo válido&quot;&#10;&#10;            estadoActual.contrasena.isBlank() -&gt;&#10;                &quot;La contraseña no puede estar vacía&quot;&#10;&#10;            estadoActual.contrasena.length &lt; 6 -&gt;&#10;                &quot;La contraseña debe tener al menos 6 caracteres&quot;&#10;&#10;            estadoActual.contrasena != estadoActual.confirmarContrasena -&gt;&#10;                &quot;Las contraseñas no coinciden&quot;&#10;&#10;            else -&gt; null&#10;        }&#10;    }&#10;&#10;    fun registrarUsuario(onRegistroExitoso: () -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            val errorValidacion = validarCampos()&#10;            if (errorValidacion != null) {&#10;                _estado.update { it.copy(error = errorValidacion) }&#10;                return@launch&#10;            }&#10;&#10;            _estado.update { it.copy(isLoading = true, error = null) }&#10;&#10;            val estadoActual = _estado.value&#10;&#10;            val result = authRepository.register(&#10;                nombre = estadoActual.nombre,&#10;                email = estadoActual.correo,&#10;                password = estadoActual.contrasena&#10;            )&#10;&#10;            result.onSuccess { response -&gt;&#10;                Log.d(&quot;RegistroViewModel&quot;, &quot;Registro exitoso - Token: ${response.token}, UserId: ${response.userId}, Username: ${response.username}&quot;)&#10;&#10;                // Extraer el nombre del token JWT si username es null&#10;                val nombre = response.username ?: try {&#10;                    extraerNombreDelToken(response.token)&#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;RegistroViewModel&quot;, &quot;Error al extraer nombre del token&quot;, e)&#10;                    estadoActual.nombre // Usar el nombre que ingresó el usuario&#10;                }&#10;&#10;                Log.d(&quot;RegistroViewModel&quot;, &quot;Nombre a guardar: $nombre&quot;)&#10;&#10;                // Guardar datos de sesión usando los datos de la respuesta&#10;                sessionManager.guardarSesionCompleta(&#10;                    idUsuario = if (response.userId &gt; 0) response.userId else 1,&#10;                    nombre = nombre,&#10;                    correo = estadoActual.correo,&#10;                    token = response.token&#10;                )&#10;&#10;                _estado.update {&#10;                    it.copy(&#10;                        registroExitoso = true,&#10;                        error = null,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;&#10;                onRegistroExitoso()&#10;            }.onFailure { error -&gt;&#10;                val mensajeError = when {&#10;                    error.message?.contains(&quot;409&quot;) == true -&gt;&#10;                        &quot;El correo ya está registrado&quot;&#10;&#10;                    error.message?.contains(&quot;timeout&quot;) == true -&gt;&#10;                        &quot;Error de conexión&quot;&#10;&#10;                    else -&gt;&#10;                        error.message ?: &quot;Error al registrar usuario&quot;&#10;                }&#10;&#10;                _estado.update {&#10;                    it.copy(&#10;                        registroExitoso = false,&#10;                        error = mensajeError,&#10;                        isLoading = false&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    private fun extraerNombreDelToken(token: String): String {&#10;        val parts = token.split(&quot;.&quot;)&#10;        if (parts.size != 3) throw IllegalArgumentException(&quot;Token JWT inválido&quot;)&#10;&#10;        val payload = String(Base64.decode(parts[1], Base64.URL_SAFE))&#10;        val json = JSONObject(payload)&#10;&#10;        // Intentar extraer el nombre de diferentes campos posibles&#10;        return json.optString(&quot;name&quot;, null)&#10;            ?: json.optString(&quot;username&quot;, null)&#10;            ?: json.optString(&quot;sub&quot;, &quot;Usuario&quot;)&#10;    }&#10;&#10;    fun clearError() {&#10;        _estado.update { it.copy(error = null) }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>